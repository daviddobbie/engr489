%% David Dobbie
% Victoria University of Wellington
% Recreating "Bayesian NMR Relaxomtery" 29 Aug - 1 Sept 2017 
% Bayesian NMR Relaxometry, paper 6
% 
% Paul Teal

%Aim: Estimating quantities like fraction of bound fluids from NMR
%relaxomtery measurements

% algorithm goes as follows:
% 


clc
clf
clear

set(0,'defaultTextInterpreter','latex');
set(0,'DefaultAxesTitleFontSizeMultiplier', 1)
set(0,'defaultAxesFontSize',14)
set(0,'DefaultAxesTitleFontSizeMultiplier', 1.1)


%loading model 2 from Gruber 2013 paper 2
density_funcload = load('model2.csv');
%density_funcload(:,2) = density_funcload(:,2)
[C,ia,ic]  = unique(density_funcload(:,1)),'stable';
density_funcload = density_funcload(ia,:);
%density_funcload = density_funcload(:~non_unique,:);
%{
figure(3)
clf
plot(density_funcload(:,1), density_funcload(:,2))
set(gca, 'XScale', 'log')
%}
%% Step 0: intialise variables

% number of data points in each dimension
N2 = 1000;
% number of bins in relaxation time grids
Ny = 30;      
%sets how many singular values we compress to
sing_val=5; %no singular values
tE = 300e-6;
%tE = 200e-6; % sample interval
T2 = logspace(-3,0.3,Ny); %form T2 domain, use log since will be small
%T2 = logspace(-5,1,Ny);
%forms measurement arrays, time tau1 and tau2 domains
tau2 = (1:N2)'*tE;  

K2 = exp(-tau2 * (1./T2) );     % simple T2 relaxation kernel


f_answer = density_funcload;
f_answer = interp1(density_funcload(:,1),density_funcload(:,2),T2,'pchip')';
porosity = trapz(f_answer);


f_answer = zeros(Ny,1)
for idx = 1:Ny
    if T2(idx)>0.09
        f_answer(idx) = 1;
    end
end
f_answer = 1*f_answer./sum(f_answer);


figure(3)
clf
plot(T2, f_answer)
set(gca, 'XScale', 'log')



noise_mean = 0;
n_std_dev = 0.02;


%% make integral transforms

Tc = 90e-3;

% make integral transform for density
porosity_density_g_vector = ones(Ny, 1);

% make integral transfrom for bfv
bfv_density_g_vector = zeros(Ny ,1);
for idx = 1:Ny
    if T2(idx)<Tc
        bfv_density_g_vector(idx) = 1;
    end
end

transform1 = porosity_density_g_vector;
transform2 = bfv_density_g_vector;
transform3 = 1 - bfv_density_g_vector;

transform4 = (0.7213 / Tc)./.*tanh(1.572*Tc*(1./T2 + 0.4087/Tc));



[alph transformResults1, transformPredict1, rmseTransform1] ...
    = bayesianEstimateIntegralTransform(transform1, f_answer, n_std_dev, noise_mean, T2, K2, tau2);

[alph transformResults2, transformPredict2, rmseTransform2] ...
    = bayesianEstimateIntegralTransform(transform2, f_answer, n_std_dev, noise_mean, T2, K2, tau2);

[alph transformResults3, transformPredict3, rmseTransform3] ...
    = bayesianEstimateIntegralTransform(transform3, f_answer, n_std_dev, noise_mean, T2, K2, tau2);




figure(2)
clf
hold on
plot(alph,transformResults1(:,1));
plot(alph,transformResults2(:,1));
plot(alph,transformResults3(:,1));
hold off
set(gca, 'XScale', 'log')
xlabel('$\alpha$')
ylabel('$\langle I \rangle$')
ylim([0 1.2])
grid on
legend('g0', 'g1', 'g2','g3','g4')

% plot variance of the estimator
figure(4)
clf
subplot(1,2,1)
hold on
plot(alph, transformPredict1)
plot(alph, transformPredict2)
plot(alph, transformPredict3)
hold off
set(gca, 'XScale', 'log')
set(gca, 'YScale', 'log')
xlabel('$\alpha$')
ylabel('$\hat{\sigma_I}$ Computed')
grid on
ylim([10e-6 10e0])

subplot(1,2,2)
hold on
plot(alph, transformResults1(:,2))
plot(alph, transformResults2(:,2))
plot(alph, transformResults3(:,2))
hold off
set(gca, 'XScale', 'log')
set(gca, 'YScale', 'log')
xlabel('$\alpha$')
ylabel('$\sigma_I$ Empirical' )
grid on
ylim([10e-6 10e0])


figure(5)
clf
hold on
plot(alph, rmseTransform1)
plot(alph, rmseTransform2)
plot(alph, rmseTransform3)
hold off
set(gca, 'XScale', 'log')
set(gca, 'YScale', 'log')
xlabel('$\alpha$')
ylabel('RMSE I Bayesian' )
grid on
ylim([10e-4 10e0])










%{
% test intergation over whole timeline window
% test different regularisation coefficients, alpha.
alpha_length = 20;
alpha_axis = logspace(-5,5,alpha_length);
num_attempts = 20;

intTransform_results = zeros(alpha_length,num_attempts);
intTransform_computed_uncertainty = zeros(alpha_length,1);

intTransform_givenalpha = zeros(alpha_length,2) %[mean, uncertainty]

for alph_idx = 1:alpha_length
    alpha = alpha_axis(alph_idx);
    alph_idx
    for idx_attempt = 1:num_attempts
        % init measured data
        noise = n_std_dev*normrnd(noise_mean, 1, [N2 ,1]);
        m = K2*f_answer + noise;  

        Cf = (n_std_dev)^2*eye(Ny)./(alpha);
        Cn = (n_std_dev)^2*eye(N2);
        
        %mu_f = mean((T2'.*f_answer)');
        mu_f =exp((log(T2))*f_answer);
        
        % create reference delta density at certain frequency point
        [diff, idx] = min(abs(T2-mu_f));
        mu_f_distrib = zeros(Ny,1); mu_f_distrib(idx,1) = 1;

        figure(99)
        clf
        hold on
        plot(tau2,m)
        plot(tau2,K2*mu_f_distrib)        
        ylim([-0.5 1.5])

        [intTrans_mean, intTrans_uncertainty] = calcNormIntegralTransformGivenMeasured(porosity_density_g_vector, m,K2, Cf, Cn, mu_f, T2);
        actual_intTransform = (porosity_density_g_vector'*f_answer);
        
        figure(44)
        hold on
        plot(T2, f_answer, '-r')
        set(gca, 'XScale', 'log')        
        
        
        intTransform_results(alph_idx,idx_attempt) = intTrans_mean;
        intTransform_computed_uncertainty(alph_idx) = intTrans_uncertainty;
    end
    
end

intTransform_givenalpha(:,1) = mean(intTransform_results')';
intTransform_givenalpha(:,2) = std(intTransform_results')';

figure(2)
clf
plot(alpha_axis,intTransform_givenalpha(:,1));
set(gca, 'XScale', 'log')
xlabel('$\alpha$')
ylabel('$\langle I \rangle$')
ylim([0 1.2])
grid on

% plot variance of the estimator
figure(4)
clf
subplot(1,2,1)
plot(alpha_axis, intTransform_computed_uncertainty)
set(gca, 'XScale', 'log')
set(gca, 'YScale', 'log')
xlabel('$\alpha$')
ylabel('$\hat{\sigma_I}$ Computed')
grid on
ylim([10e-6 10e0])

subplot(1,2,2)
plot(alpha_axis, intTransform_givenalpha(:,2))
set(gca, 'XScale', 'log')
set(gca, 'YScale', 'log')
xlabel('$\alpha$')
ylabel('$\sigma_I$ Empirical' )
grid on
ylim([10e-6 10e0])

% plot rmse of the porosity estimator

rmse_bayesian = sqrt(mean(((intTransform_results - actual_intTransform).^2)'));


figure(5)
clf

plot(alpha_axis, rmse_bayesian)
set(gca, 'XScale', 'log')
set(gca, 'YScale', 'log')
xlabel('$\alpha$')
ylabel('RMSE I Bayesian' )
grid on
ylim([10e-4 10e0])
%}


%{
[bfv_mean bfv_uncertainty] = calcNormIntegralTransformGivenMeasured(bfv_density_g_vector, m,K2, Cf, Cn, mu_f)
actual_bfv = (bfv_density_g_vector'*f_answer)

est_bff = bfv_mean ./ poro_mean
actual_bff = (bfv_density_g_vector'*f_answer) / (intTransform_density_g_vector'*f_answer)
%}

%% functions

% Calculates the two parameters of a normally distributed general integral
% transform given measurement data. Implements equation 19.
% INPUTS: 
%    g: the integral transform in the T2 domain
%    m: measured data vector
%    K: exponential kernel mapping from the T2 to time domain
%    Cf: covariance of density function f
%    Cn: covariance of measurement noise
%    mu_f: mean of density function
% OUTPUTS:
%    mean: mean of the integral transform estimation
%    std_dev: standard deviation of integral transform estimation
function [mean std_dev] = calcNormIntegralTransformGivenMeasured(g, m, K, Cf, Cn, mu_f, T2)

    R = Cf * K' * inv(K* Cf * K' + Cn);
    %{
    [diff, idx] = min(abs(T2-mu_f));
    mu_f_distrib = zeros(length(T2),1); mu_f_distrib(idx,1) = 1;
    %}
    mu_f_distrib = zeros(length(T2),1); %a zero prior
    
    %{
    figure(44)
    clf
    plot(T2, R * (m - K*mu_f_distrib) - mu_f_distrib)
    set(gca, 'XScale', 'log')
    ylim([0 0.1])
    grid on
    %}
    
    %mean = g' * (  R * (m - K*mu_f_distrib) + mu_f_distrib);
    mean = g' * (  R * (m - K*mu_f_distrib) - mu_f_distrib);
    std_dev = sqrt(g'  *   (Cf - R*K*Cf')  *  g);
    %std_dev = g'  *   inv(   inv(Cf) + K' *inv(Cn) * K  )  *  g;
end

% Performs the prediction of the resulting integral transform with multiple
% initialiasations of the noise. This is used the assess the performance of
% the algorithm
% INPUTS: 
%    g: 
% OUTPUTS:
function [alpha_axis, intTransform_givenalpha, intTransform_computed_uncertainty, rmse_bayesian]  = ...
    bayesianEstimateIntegralTransform(g_intTransform,  f_answer, n_std_dev, noise_mean, T2, K2, tau2)
    % test intergation over whole timeline window
    % test different regularisation coefficients, alpha.
    N2 = length(tau2);
    Ny = length(T2);
    
    alpha_length = 20;
    alpha_axis = logspace(-5,5,alpha_length);
    num_attempts = 10;

    intTransform_results = zeros(alpha_length,num_attempts);
    intTransform_computed_uncertainty = zeros(alpha_length,1);

    intTransform_givenalpha = zeros(alpha_length,2) %[mean, uncertainty]

    for alph_idx = 1:alpha_length
        alpha = alpha_axis(alph_idx);
        alph_idx
        for idx_attempt = 1:num_attempts
            % init measured data
            noise = n_std_dev*normrnd(noise_mean, 1, [N2 ,1]);
            m = K2*f_answer + noise;  

            Cf = (n_std_dev)^2*eye(Ny)./(alpha);
            Cn = (n_std_dev)^2*eye(N2);

            %mu_f = mean((T2'.*f_answer)');
            mu_f =exp((log(T2))*f_answer);

            % create reference delta density at certain frequency point
            [diff, idx] = min(abs(T2-mu_f));
            mu_f_distrib = zeros(Ny,1); mu_f_distrib(idx,1) = 1;
            
            %{
            figure(99)
            clf
            hold on
            plot(tau2,m)
            plot(tau2,K2*mu_f_distrib)        
            ylim([-0.5 1.5])
            %}
            
            [intTrans_mean, intTrans_uncertainty] = calcNormIntegralTransformGivenMeasured(g_intTransform, m,K2, Cf, Cn, mu_f, T2);
            actual_intTransform = (g_intTransform'*f_answer);
            
            %{
            figure(44)
            hold on
            plot(T2, f_answer, '-r')
            set(gca, 'XScale', 'log')        
            %}

            intTransform_results(alph_idx,idx_attempt) = intTrans_mean;
            intTransform_computed_uncertainty(alph_idx) = intTrans_uncertainty;
        end

    end

    intTransform_givenalpha(:,1) = mean(intTransform_results')';
    intTransform_givenalpha(:,2) = std(intTransform_results')';

    % plot rmse of the porosity estimator
    rmse_bayesian = sqrt(mean(((intTransform_results - actual_intTransform).^2)'));    
    
 
%{
    figure(2)
    clf
    plot(alpha_axis,intTransform_givenalpha(:,1));
    set(gca, 'XScale', 'log')
    xlabel('$\alpha$')
    ylabel('$\langle I \rangle$')
    ylim([0 1.2])
    grid on

    % plot variance of the estimator
    figure(4)
    clf
    subplot(1,2,1)
    plot(alpha_axis, intTransform_computed_uncertainty)
    set(gca, 'XScale', 'log')
    set(gca, 'YScale', 'log')
    xlabel('$\alpha$')
    ylabel('$\hat{\sigma_I}$ Computed')
    grid on
    ylim([10e-6 10e0])

    subplot(1,2,2)
    plot(alpha_axis, intTransform_givenalpha(:,2))
    set(gca, 'XScale', 'log')
    set(gca, 'YScale', 'log')
    xlabel('$\alpha$')
    ylabel('$\sigma_I$ Empirical' )
    grid on
    ylim([10e-6 10e0])


    figure(5)
    clf

    plot(alpha_axis, rmse_bayesian)
    set(gca, 'XScale', 'log')
    set(gca, 'YScale', 'log')
    xlabel('$\alpha$')
    ylabel('RMSE I Bayesian' )
    grid on
    ylim([10e-4 10e0])
    %}
end





